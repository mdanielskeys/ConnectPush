// ConnectPush.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <memory>
#include <Windows.h>
#include <mmsystem.h>
#include "ConnectPush.h"

const int ERR_MSG_SIZE = 120;
const int PAD_OFFSET = 36;
const BYTE MIDI_WRITE_PAD = 144;

const BYTE WHITE = 122;
const BYTE BLUE = 125;
const BYTE RED = 127;
const BYTE GREEN = 126;
const BYTE DARK_GRAY = 124;
const BYTE LIGHT_GRAY = 123;
const BYTE YELLOW = 6;
const BYTE BLACK = 0;

BYTE drawpad = 0;
BYTE gColor = WHITE;
bool gCycle = false;

void CALLBACK MidiInProc(HMIDIIN hmidiin, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
	WORD hWord = HIWORD(dwParam1);
	BYTE hwlByte = LOBYTE(hWord);

	WORD lWord = LOWORD(dwParam1);
	BYTE lwhByte = HIBYTE(lWord);
	WORD midiData = lwhByte;
	midiData = midiData << 8;
	midiData |= hwlByte;
	BYTE midiStatus = LOBYTE(lWord);

	std::string msg = "cc";
	switch (midiStatus)
	{
	case 0xb0:
		msg = "cc";
		break;
	case 0x90:
		drawpad = lwhByte;
	case 0x80:
		msg = "nn";
		break;
	}

	std::cout << std::hex;
	std::cout << "In callback procedure" << "\n";
	std::cout << "\tMessage " << uMsg << "\n";
	std::cout << "\tdwInstance " << dwInstance << "\n";
	std::cout << "\tMidi Message " << (int)midiStatus << " " << std::dec << msg << (int)lwhByte << " : " << (int)hwlByte << "\n";
	std::cout << "\tTimestamp " << std::dec << dwParam2 << "\n";
}

void CALLBACK MidiOutProc(
	HMIDIOUT  hmo,
	UINT      wMsg,
	DWORD_PTR dwInstance,
	DWORD_PTR dwParam1,
	DWORD_PTR dwParam2
)
{
	union {
		DWORD dwData;
		BYTE bData[4];
	} u;

	u.dwData = dwParam1;

	std::cout << "Out callback procedure" << "\n";
	std::cout << "\tMessage " << wMsg << "\n";
	std::cout << "\tdwInstance " << dwInstance << "\n";
	std::cout << "\tdwParam1 " << dwParam1 << "\n";
	std::cout << "\tdwParam2 " << dwParam2 << "\n";

}

void SysExCall(const HMIDIOUT& hMidiOut, LPSTR  buffer, DWORD cbLength)
{
	MIDIHDR midiOutHdr{ 0 };
	midiOutHdr.lpData = buffer;
	midiOutHdr.dwBufferLength = cbLength;
	midiOutHdr.dwFlags = 0;

	MMRESULT result = midiOutPrepareHeader(hMidiOut, &midiOutHdr, sizeof(MIDIHDR));
	if (MMSYSERR_NOERROR == result)
	{
		result = midiOutLongMsg(hMidiOut, &midiOutHdr, sizeof(midiOutHdr));
		if (MMSYSERR_NOERROR != result)
		{
			TCHAR errMsg[ERR_MSG_SIZE];
			midiOutGetErrorText(result, errMsg, ERR_MSG_SIZE);
			std::cout << "Error: " << errMsg << "\n";
		}
	}


	while (MIDIERR_STILLPLAYING == midiOutUnprepareHeader(hMidiOut, &midiOutHdr, sizeof(MIDIHDR))) {}
}

void SetUserModeOn(HMIDIOUT hMidiOut)
{
	const BYTE sysExMsg[] = { 0xF0, 0x00, 0x21, 0x1D, 0x01, 0x01, 0x0A, 0x01, 0xF7 };

	SysExCall(hMidiOut, (LPSTR)sysExMsg, sizeof(sysExMsg));
}

void SetLiveModeOn(HMIDIOUT hMidiOut)
{
	const BYTE sysExMsg[] = { 0xF0, 0x00, 0x21, 0x1D, 0x01, 0x01, 0x0A, 0x00, 0xF7 };

	SysExCall(hMidiOut, (LPSTR)sysExMsg, sizeof(sysExMsg));
}

BYTE font8x8_basic[128][8] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
	{ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
	{ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
	{ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
	{ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
	{ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
	{ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
	{ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
	{ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
	{ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
	{ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
	{ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
	{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
	{ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
	{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
	{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
	{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
	{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
	{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
	{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
	{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
	{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
	{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
	{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
	{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
	{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
	{ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
	{ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
	{ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
	{ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
	{ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
	{ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
	{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
	{ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
	{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
	{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
	{ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
	{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
	{ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
	{ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
	{ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
	{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
	{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
	{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
	{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
	{ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
	{ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
	{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
	{ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
	{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
	{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
	{ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
	{ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
	{ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
	{ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
	{ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
	{ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
	{ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
	{ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
	{ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
	{ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
	{ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
	{ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
	{ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
	{ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
	{ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
	{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
	{ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
	{ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
	{ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
	{ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
	{ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
	{ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
	{ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
	{ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
	{ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
	{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
	{ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
	{ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
	{ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
	{ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
	{ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
	{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
	{ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
	{ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
	{ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
	{ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
	{ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};

BYTE character_model[64] = {
	000,122,000,000,000,000,000,122,
	000,122,122,122,122,122,122,122,
	000,122,123,127,123,123,123,127,
	125,122,123,123,123,123,123,123,
	125,122,122,122,122,122,122,122,
	123,125,125,125,125,125,125,125,
	000,125,125,125,125,125,125,125,
	000,126,126,000,000,000,126,126
};

void DrawPadColor(HMIDIOUT hMidiOut, BYTE bPadNumber, BYTE bColor)
{
	union {
		DWORD dwData;
		BYTE bData[4];
	} u;

	u.dwData = 0;
	// Construct the MIDI message. 
	u.bData[0] = MIDI_WRITE_PAD;	// MIDI status byte 
	u.bData[1] = bPadNumber;		// first MIDI data byte 
	u.bData[2] = bColor;			// second MIDI data byte 
	u.bData[3] = 0;

	MMRESULT result = midiOutShortMsg(hMidiOut, u.dwData);
	switch (result)
	{
	case MIDIERR_BADOPENMODE:
		std::cout << "Bad Open Mode" << "\n";
		break;
	case MIDIERR_NOTREADY:
		std::cout << "Not ready" << "\n";
		break;
	case MMSYSERR_INVALHANDLE:
		std::cout << "Invalid handle" << "\n";
		break;
	default:
		break;
	}
}

void ClearPads(HMIDIOUT hMidiOut)
{
	union {
		DWORD dwData;
		BYTE bData[4];
	} u;

	SetUserModeOn(hMidiOut);
	for (int i = 36; i <= 99; i++)
	{
		u.dwData = 0;
		DrawPadColor(hMidiOut, i, 0);
	}
	SetLiveModeOn(hMidiOut);
}

void DrawCharacter(HMIDIOUT hMidiOut)
{
	union {
		DWORD dwData;
		BYTE bData[4];
	} u;
	BYTE drawsideup_charecter[64]{ 0 };
	for (int i = 0, j = 63; i < 64; i++, j--)
	{ 
		drawsideup_charecter[i] = character_model[j];
	}

	ClearPads(hMidiOut);

	SetUserModeOn(hMidiOut);
	for (int x = 0; x < 64; x++)
	{
		DrawPadColor(hMidiOut, x + PAD_OFFSET, drawsideup_charecter[x]);
	}
	SetLiveModeOn(hMidiOut);
}


void DrawLetter(HMIDIOUT hMidiOut, const BYTE* pLetter)
{
	union {
		DWORD dwData;
		BYTE bData[4];
	} u;

	ClearPads(hMidiOut);

	BYTE rLetter[8];
	for (int i = 0, j = 7; i < 8; i++, j--)
	{
		rLetter[i] = pLetter[j];
	}

	BYTE color = (rand() % 8) + 30;

	SetUserModeOn(hMidiOut);
	for (int x = 0; x < 8; x++) {
		for (int y = 0; y < 8; y++) {
			int set = rLetter[x] & 1 << y;
			if (set)
			{
				DrawPadColor(hMidiOut, (x * 8) + y + PAD_OFFSET, color);
			}
		}
	}

	SetLiveModeOn(hMidiOut);
}


const TCHAR* DeviceOutputName1 = L"Ableton Push 2";
const TCHAR* DeviceOutputName2 = L"MIDIOUT2 (Ableton Push 2)";

const TCHAR* DeviceInputName1 = L"MIDIIN2(Ableton Push 2)";
const TCHAR* DeviceInputName2 = L"Ableton Push 2";

int main()
{
	UINT numInMidiDevices = midiInGetNumDevs();
	UINT numOutMidiDevices = midiOutGetNumDevs();
	UINT outputDeviceId2= -1;
	UINT inputDeviceId2 = -1;

    std::cout << "Number of in midi devices: " << numInMidiDevices << "\n";
	std::cout << "Number of out midi devices: " << numOutMidiDevices << "\n";

	// Get device capabilities for each input device
	for (UINT i = 0; i < numInMidiDevices; i++)
	{
		MIDIINCAPS midicaps;
		UINT cbMidiCaps = sizeof(MIDIINCAPS);

		MMRESULT result = midiInGetDevCaps(i, &midicaps, cbMidiCaps);
		if (MMSYSERR_NOERROR == result)
		{
			if (wcsncmp(DeviceInputName2, midicaps.szPname, sizeof(DeviceInputName2)) == 0)
			{
				inputDeviceId2 = i;
			}
			std::wcout << "Input device " << i << ": " << midicaps.szPname << "\n";
		}
	}
	std::cout << "\n";

	// Get the device capabilities for each output device
	for (UINT i = 0; i < numOutMidiDevices; i++)
	{
		MIDIOUTCAPS midicaps;
		UINT cbMidiCaps = sizeof(MIDIOUTCAPS);

		MMRESULT result = midiOutGetDevCaps(i, &midicaps, cbMidiCaps);
		if (MMSYSERR_NOERROR == result)
		{
			if (wcsncmp(DeviceOutputName2, midicaps.szPname, sizeof(DeviceOutputName2)) == 0)
			{
				outputDeviceId2 = i;
			}
			std::wcout << "Output device " << i << ": " << midicaps.szPname << "\n";
		}
	}

	// Setup midi connection to push 2
	HMIDIOUT hMidiOut1;
	MMRESULT result = midiOutOpen(&hMidiOut1, outputDeviceId2, (DWORD_PTR)MidiOutProc, NULL, CALLBACK_FUNCTION);
	if (MMSYSERR_NOERROR != result) return 0;

	HMIDIIN hMidiIn1;
	result = midiInOpen(&hMidiIn1, inputDeviceId2, (DWORD_PTR)MidiInProc, NULL, CALLBACK_FUNCTION);
	if (MMSYSERR_NOERROR != result) {
		midiOutClose(hMidiOut1);
		return 0;
	}


	//BYTE arg[] = { 0x40 };
	//SendSysExCommand(hMidiOut1, 0x06, arg, 1);



	//result = midiInStart(hMidiIn1);
	// Loop for midi 
	BYTE phrase[] = { 'H','I',' ','K','A','R','L',' ' };


	result = midiInStart(hMidiIn1);
	ClearPads(hMidiOut1);

	bool run = true;
	while (run)
	{
		if (GetAsyncKeyState('Q') & 0x0001)
		{
			std::cout << "Quiting application" << "\n";
			run = false;
		}
		if (GetAsyncKeyState('W') & 0x0001)
		{
			gColor = WHITE;
			std::cout << "Color set to white" << "\n";
		}

		if (GetAsyncKeyState('B') & 0x0001)
		{
			gColor = BLUE;
			std::cout << "Color set to blue" << "\n";
		}
		if (GetAsyncKeyState('R') & 0x0001)
		{
			gColor = RED;
			std::cout << "Color set to red" << "\n";
		}
		if (GetAsyncKeyState('G') & 0x0001)
		{
			gColor = GREEN;
			std::cout << "Color set to green" << "\n";
		}
		if (GetAsyncKeyState('D') & 0x0001)
		{
			gColor = DARK_GRAY;
			std::cout << "Color set to dark gray" << "\n";
		}
		if (GetAsyncKeyState('L') & 0x0001)
		{
			gColor = LIGHT_GRAY;
			std::cout << "Color set to light gray" << "\n";
		}
		if (GetAsyncKeyState('Y') & 0x0001)
		{
			gColor = YELLOW;
			std::cout << "Color set to yellow" << "\n";
		}

		if (GetAsyncKeyState('Z') & 0x0001)
		{
			gColor = BLACK;
			std::cout << "Color set to black" << "\n";
		}
		if (GetAsyncKeyState('U') & 0x0001)
		{
			gColor = BLACK;
			gCycle = !gCycle;
			if (gCycle)
				std::cout << "Color set to cycle mode" << "\n";
			else
				std::cout << "Cycle mode set off" << "\n";
		}

		if (drawpad != 0)
		{
			if (gCycle)
			{
				gColor += 1;
				if (gColor > 127) gColor = 0;
				
				std::cout << "Color number is " << (int)gColor << "\n";
			}

			SetUserModeOn(hMidiOut1);
			DrawPadColor(hMidiOut1, drawpad, gColor);
			SetLiveModeOn(hMidiOut1);
			drawpad = 0;
		}
	}

	midiInStop(hMidiIn1);

	// Close out midi connection to push 2
	midiInClose(hMidiIn1);
	midiOutClose(hMidiOut1);
}

